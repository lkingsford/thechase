import random
import game_tile
import evil_tree
import cultist
import spectre
import flame

from enum import Enum

TYPES_OF_WALLS = 6;
TYPES_OF_FLOORS = 6;
ENEMY_CHANCE = 0.25;

class GameMap:
    """ The main game map.
    This is not a generically useful map for any roguelike game as it does
    some things in slower then usual ways in order to facilitate the horizontal
    scrolling.
    Make a game not an engine amirite?!
    
    The map has floors and walls. Floors are an integer saying which floor
    (in reality - 0 to 5 are different grasses). Walls are 0 if no wall, 
    otherwise 1-6 saying which type of tree
    """
    def __init__(self, active_size, extra_width):
        """ Initialise the map
        Keyword arguments:
            active_size - (width, height) of the play area
            extra_width - amount of columns to prepare beyond active_size
        Returns:
            none
        """       
        self.active_size = active_size
        
        # Initialise asset lists
        self.GrassAssets = [\
            "Grass1",
            "Grass2",
            "Grass3",
            "Grass4",
            "Grass5",
            "Grass6"]
        
        self.TreeAssets = [\
            "Tree1",
            "Tree2",
            "Tree3",
            "Tree4",
            "Tree5",
            "Tree6"]
            
        self.inner_map = []
                    
        self.characters = []    
        
        for i in range(active_size[0] + extra_width):
            self.add_column(0.2);        

    
    def scroll(self):
        """ Scroll the map to the left
            Keyword arguments:
                none
            Returns:
                none
        """    
        # Remove leftmost colum
        self.inner_map.pop(0)
        
        # Update characters locations
        for i in self.characters:
            i.location = i.location[0] - 1, i.location[1]            
            # Remove characters who are no longer active
            if (i.location[0] < 1):
                self.characters.remove(i)

        
        # Create new column
        self.add_column(0.2)
        
        
    def add_column(self, blocked_amount):
        """ Add another column of map to the right
            Keyword arguments:
                blocked_amount - chance that any square will be blocked
            Returns:
                none
        """
        new_column = []
        for i in range(self.active_size[1]):
            # Check if blocked
            blocked = random.random() < blocked_amount
            # Force blocked if first or last tile
            if (i == 0) or (i == (self.active_size[1] - 1)):
                blocked = True
            # Pick a type of floor
            floor_asset = random.choice(self.GrassAssets)
            # If blocked, pick type of walls
            if blocked:
                wall_asset = random.choice(self.TreeAssets)
            else:
                wall_asset = None;
                
            new_column.append(game_tile.GameTile(floor_asset,
                wall_asset, not(blocked)))
        
        # Maybe add an enemy
        new_enemy = random.random() < ENEMY_CHANCE
        if new_enemy:
            y = random.randint(0, self.active_size[1] - 1)
            while (not(new_column[y].walkable())):
                y = random.randint(0, self.active_size[1] - 1)
            monster = random.choice ([
                flame.Flame,
                evil_tree.EvilTree,
                cultist.Cultist,
                spectre.Spectre
                ])((len(self.inner_map), y), self)
            
        
        self.inner_map.append(new_column);
        
    
    def walkable(self, location):
        if (0 <= location[0] < self.active_size[0]) and \
            (0 <= location[1] < self.active_size[1]):
            return self.inner_map[location[0]][location[1]].walkable()
        else:
            return False
